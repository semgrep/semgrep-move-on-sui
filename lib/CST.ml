(* Generated by ocaml-tree-sitter. *)
(*
   move_on_sui grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type clean_identifier = Token.t (* pattern (`)?[a-zA-Z_][0-9a-zA-Z_]*(`)? *)

type bool_literal = [
    `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
]

type untyped_num_literal = Token.t (* pattern 0x[a-fA-F0-9_]+ *)

type macro_identifier_dollar = Token.t (* pattern \$[a-zA-Z][0-9a-zA-Z_]* *)

type spec_condition_kind = [
    `Assert of Token.t (* "assert" *)
  | `Assume of Token.t (* "assume" *)
  | `Decres of Token.t (* "decreases" *)
  | `Ensures of Token.t (* "ensures" *)
  | `Succes_if of Token.t (* "succeeds_if" *)
]

type address_literal = Token.t (* pattern @0x[a-fA-F0-9]+ *)

type byte_string_literal = Token.t (* pattern "b\"(\\\\.|[^\\\\\"])*\"" *)

type primitive_type = [
    `U8 of Token.t (* "u8" *)
  | `U16 of Token.t (* "u16" *)
  | `U32 of Token.t (* "u32" *)
  | `U64 of Token.t (* "u64" *)
  | `U128 of Token.t (* "u128" *)
  | `U256 of Token.t (* "u256" *)
  | `Bool of Token.t (* "bool" *)
  | `Addr of Token.t (* "address" *)
  | `Signer of Token.t (* "signer" *)
  | `Byte of Token.t (* "bytearray" *)
]

type semgrep_metavar_var = Token.t (* pattern \$[A-Z_][A-Z_0-9]* *)

type identifier =
  Token.t (* pattern (`)?[a-zA-Z_][0-9a-zA-Z_]*(`)?|\$\.\.\.[A-Z_][A-Z_0-9]*]|\$[A-Z_][A-Z_0-9]* *)

type modifier = [
    `Public of Token.t (* "public" *)
  | `Publ_83d19bc of Token.t (* "public(package)" *)
  | `Publ_7c2e49a of Token.t (* "public(friend)" *)
  | `Entry of Token.t (* "entry" *)
  | `Native of Token.t (* "native" *)
]

type spec_apply_name_pattern = Token.t (* pattern [0-9a-zA-Z_*]+ *)

type hex_string_literal = Token.t (* pattern "x\"[0-9a-fA-F]*\"" *)

type unary_op = [ `BANG of Token.t (* "!" *) ]

type unit_expression = (Token.t (* "(" *) * Token.t (* ")" *))

type typed_num_literal =
  Token.t (* pattern [0-9][0-9_]*(?:u8|u16|u32|u64|u128|u256)? *)

type semgrep_metavar_ellipsis =
  Token.t (* pattern \$\.\.\.[A-Z_][A-Z_0-9]* *)

type anon_choice_AMP_c6caa5d = [
    `AMP of Token.t (* "&" *)
  | `AMPmut of Token.t (* "&mut" *)
]

type ability = [
    `Choice_copy of [
        `Copy of Token.t (* "copy" *)
      | `Drop of Token.t (* "drop" *)
      | `Store of Token.t (* "store" *)
      | `Key of Token.t (* "key" *)
    ]
  | `Ellips of Token.t (* "..." *)
]

type reserved_identifier = [
    `Forall of Token.t (* "forall" *)
  | `Exists of Token.t (* "exists" *)
]

type num_literal = [
    `Typed_num_lit of typed_num_literal (*tok*)
  | `Unty_num_lit of untyped_num_literal (*tok*)
]

type identifier_or_metavariable = [
    `Choice_macro_id_dollar of [
        `Macro_id_dollar of macro_identifier_dollar (*tok*)
      | `Semg_meta_ellips of semgrep_metavar_ellipsis (*tok*)
      | `Semg_meta_var of semgrep_metavar_var (*tok*)
      | `X__ of Token.t (* "_" *)
    ]
  | `Opt_phan_clean_id of (
        Token.t (* "phantom" *) option
      * clean_identifier (*tok*)
    )
]

type postfix_ability_decls = (
    Token.t (* "has" *)
  * (ability * Token.t (* "," *)) list (* zero or more *)
  * ability option
  * Token.t (* ";" *)
)

type ability_decls = (
    Token.t (* "has" *)
  * (ability * Token.t (* "," *)) list (* zero or more *)
  * ability option
)

type label = (Token.t (* "'" *) * identifier (*tok*))

type use_member = [
    `Choice_id_COLONCOLON_LCURL_use_member_rep_COMMA_use_member_opt_COMMA_RCURL of [
        `Id_COLONCOLON_LCURL_use_member_rep_COMMA_use_member_opt_COMMA_RCURL of (
            identifier (*tok*)
          * Token.t (* "::" *)
          * Token.t (* "{" *)
          * use_member
          * (Token.t (* "," *) * use_member) list (* zero or more *)
          * Token.t (* "," *) option
          * Token.t (* "}" *)
        )
      | `Id_COLONCOLON_id_opt_as_id of (
            identifier (*tok*)
          * Token.t (* "::" *)
          * identifier (*tok*)
          * (Token.t (* "as" *) * identifier (*tok*)) option
        )
      | `Id_opt_as_id of (
            identifier (*tok*)
          * (Token.t (* "as" *) * identifier (*tok*)) option
        )
    ]
  | `Ellips of Token.t (* "..." *)
]

type anon_choice_num_lit_a33e50c = [
    `Num_lit of num_literal
  | `Module_id of identifier (*tok*)
]

type literal_value = [
    `Addr_lit of address_literal (*tok*)
  | `Bool_lit of bool_literal
  | `Num_lit of num_literal
  | `Hex_str_lit of hex_string_literal (*tok*)
  | `Byte_str_lit of byte_string_literal (*tok*)
]

type type_parameter = [
    `Id_or_meta_opt_COLON_abil_rep_PLUS_abil_opt_PLUS of (
        identifier_or_metavariable
      * (
            Token.t (* ":" *)
          * ability
          * (Token.t (* "+" *) * ability) list (* zero or more *)
          * Token.t (* "+" *) option
        )
          option
    )
  | `Ellips of Token.t (* "..." *)
]

type block_identifier = (label * Token.t (* ":" *))

type continue_expression = (Token.t (* "continue" *) * label option)

type module_identity = (
    anon_choice_num_lit_a33e50c * Token.t (* "::" *) * identifier (*tok*)
)

type spec_property = (
    identifier (*tok*)
  * (Token.t (* "=" *) * literal_value) option
)

type type_parameters = (
    Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ">" *)
)

type module_access = [
    `Choice_semg_meta_ellips of [
        `Semg_meta_ellips of semgrep_metavar_ellipsis (*tok*)
      | `Macro_id_dollar of macro_identifier_dollar (*tok*)
      | `Id of identifier (*tok*)
    ]
  | `AT_id of (Token.t (* "@" *) * identifier (*tok*))
  | `Rese_id of reserved_identifier
  | `Module_id_COLONCOLON_id of (
        identifier (*tok*) * Token.t (* "::" *) * identifier (*tok*)
    )
  | `Module_iden_COLONCOLON_id of (
        module_identity * Token.t (* "::" *) * identifier (*tok*)
    )
  | `Module_iden_COLONCOLON_id_COLONCOLON_id of (
        module_identity * Token.t (* "::" *) * identifier (*tok*)
      * Token.t (* "::" *) * identifier (*tok*)
    )
  | `Ellips of Token.t (* "..." *)
]

type use_module_members = [
    `Choice_num_lit_COLONCOLON_LCURL_use_member_rep_COMMA_use_member_opt_COMMA_RCURL of (
        anon_choice_num_lit_a33e50c
      * Token.t (* "::" *)
      * Token.t (* "{" *)
      * use_member
      * (Token.t (* "," *) * use_member) list (* zero or more *)
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
  | `Module_iden_COLONCOLON_LCURL_use_member_rep_COMMA_use_member_opt_COMMA_RCURL of (
        module_identity
      * Token.t (* "::" *)
      * Token.t (* "{" *)
      * use_member
      * (Token.t (* "," *) * use_member) list (* zero or more *)
      * Token.t (* "," *) option
      * Token.t (* "}" *)
    )
]

type use_module_member = (module_identity * Token.t (* "::" *) * use_member)

type use_module = (
    module_identity
  * (Token.t (* "as" *) * identifier (*tok*)) option
)

type friend_access = [
    `Id of identifier (*tok*)
  | `Module_iden of module_identity
]

type condition_properties = (
    Token.t (* "[" *)
  * (spec_property * Token.t (* "," *)) list (* zero or more *)
  * spec_property option
  * Token.t (* "]" *)
)

type spec_pragma = (
    Token.t (* "pragma" *)
  * (spec_property * Token.t (* "," *)) list (* zero or more *)
  * spec_property option
  * Token.t (* ";" *)
)

type enum_signature = (
    Token.t (* "enum" *)
  * identifier (*tok*)
  * type_parameters option
  * ability_decls option
)

type spec_apply_pattern = (
    [ `Public of Token.t (* "public" *) | `Inte of Token.t (* "internal" *) ]
      option
  * spec_apply_name_pattern (*tok*)
  * type_parameters option
)

type struct_signature = (
    Token.t (* "struct" *)
  * identifier (*tok*)
  * type_parameters option
  * ability_decls option
)

type use_fun = (
    Token.t (* "fun" *) * module_access * Token.t (* "as" *) * module_access
  * Token.t (* "." *) * identifier (*tok*)
)

type apply_type = (module_access * type_arguments option)

and function_type = (
    function_type_parameters
  * (Token.t (* "->" *) * type_) option
)

and function_type_parameters = (
    Token.t (* "|" *)
  * (type_ * Token.t (* "," *)) list (* zero or more *)
  * type_ option
  * Token.t (* "|" *)
)

and ref_type = (anon_choice_AMP_c6caa5d * type_)

and tuple_type = (
    Token.t (* "(" *)
  * (type_ * Token.t (* "," *)) list (* zero or more *)
  * type_ option
  * Token.t (* ")" *)
)

and type_ = [
    `Choice_apply_type of [
        `Apply_type of apply_type
      | `Ref_type of ref_type
      | `Tuple_type of tuple_type
      | `Func_type of function_type
      | `Prim_type of primitive_type
    ]
  | `Ellips of Token.t (* "..." *)
]

and type_arguments = [
    `LT_type_rep_COMMA_type_opt_COMMA_GT of (
        Token.t (* "<" *)
      * type_
      * (Token.t (* "," *) * type_) list (* zero or more *)
      * Token.t (* "," *) option
      * Token.t (* ">" *)
    )
  | `Ellips of Token.t (* "..." *)
  | `LT_ellips_GT of (
        Token.t (* "<" *) * Token.t (* "..." *) * Token.t (* ">" *)
    )
]

type annotation_expr = [
    `Id of identifier (*tok*)
  | `Id_EQ_choice_COLONCOLON_module_access of (
        identifier (*tok*)
      * Token.t (* "=" *)
      * [
            `COLONCOLON_module_access of (Token.t (* "::" *) * module_access)
          | `Module_access of module_access
          | `Lit_value of literal_value
        ]
    )
]

type macro_module_access = (module_access * Token.t (* "!" *))

type friend_declaration = (
    Token.t (* "friend" *) * friend_access * Token.t (* ";" *)
)

type spec_block_target = [
    `Id of identifier (*tok*)
  | `Module of Token.t (* "module" *)
  | `Spec_blk_target_schema of (
        Token.t (* "schema" *)
      * identifier (*tok*)
      * type_parameters option
    )
]

type use_declaration = (
    Token.t (* "public" *) option
  * Token.t (* "use" *)
  * [
        `Use_fun of use_fun
      | `Use_module of use_module
      | `Use_module_member of use_module_member
      | `Use_module_members of use_module_members
    ]
  * Token.t (* ";" *)
)

type name_expression = (module_access * type_arguments option)

type spec_variable = (
    [ `Global of Token.t (* "global" *) | `Local of Token.t (* "local" *) ]
      option
  * identifier (*tok*)
  * type_parameters option
  * Token.t (* ":" *)
  * type_
  * Token.t (* ";" *)
)

type field_annotation = [
    `Field_id_COLON_type of (identifier (*tok*) * Token.t (* ":" *) * type_)
  | `Ellips of Token.t (* "..." *)
]

type function_parameter = [
    `Opt_mut_id_or_meta_COLON_type of (
        Token.t (* "mut" *) option
      * identifier_or_metavariable
      * Token.t (* ":" *)
      * type_
    )
  | `Ellips of Token.t (* "..." *)
]

type ret_type = (Token.t (* ":" *) * type_)

type annotation_item = [
    `Choice_anno_expr of [
        `Anno_expr of annotation_expr
      | `Anno_list of annotation_list
    ]
  | `Ellips of Token.t (* "..." *)
]

and annotation_list = (
    identifier (*tok*)
  * Token.t (* "(" *)
  * anon_choice_lit_value_3ef3d77
  * (Token.t (* "," *) * anon_choice_lit_value_3ef3d77)
      list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and anon_choice_lit_value_3ef3d77 = [
    `Lit_value of literal_value
  | `Anno_item of annotation_item
  | `Module_access of module_access
  | `COLONCOLON_module_access of (Token.t (* "::" *) * module_access)
]

type function_parameters = (
    Token.t (* "(" *)
  * (function_parameter * Token.t (* "," *)) list (* zero or more *)
  * function_parameter option
  * Token.t (* ")" *)
)

type datatype_fields = [
    `Posi_fields of (
        Token.t (* "(" *)
      * (type_ * Token.t (* "," *)) list (* zero or more *)
      * type_ option
      * Token.t (* ")" *)
    )
  | `Named_fields of (
        Token.t (* "{" *)
      * (field_annotation * Token.t (* "," *)) list (* zero or more *)
      * field_annotation option
      * Token.t (* "}" *)
    )
]

type spec_function_signature = (
    identifier (*tok*)
  * type_parameters option
  * function_parameters
  * ret_type
)

type function_signature = (
    modifier option
  * modifier option
  * Token.t (* "fun" *)
  * identifier (*tok*)
  * type_parameters option
  * function_parameters
  * ret_type option
)

type macro_signature = (
    modifier option
  * Token.t (* "fun" *)
  * identifier (*tok*)
  * type_parameters option
  * function_parameters
  * ret_type option
)

type variant = (identifier (*tok*) * datatype_fields option)

type enum_variants = (
    Token.t (* "{" *)
  * (variant * Token.t (* "," *)) list (* zero or more *)
  * variant option
  * Token.t (* "}" *)
)

type struct_item = [
    `Native_struct_defi of (
        Token.t (* "public" *) option
      * Token.t (* "native" *)
      * struct_signature
      * Token.t (* ";" *)
    )
  | `Struct_defi of (
        Token.t (* "public" *) option
      * struct_signature
      * datatype_fields
      * postfix_ability_decls option
    )
]

type abort_expression = (Token.t (* "abort" *) * expression)

and access_field = (
    dot_or_index_chain
  * Token.t (* "." *)
  * [ `Exp of expression ]
)

and annotation_expression = (
    Token.t (* "(" *) * expression * Token.t (* ":" *) * type_
  * Token.t (* ")" *)
)

and arg_list = (
    Token.t (* "(" *)
  * (expression * Token.t (* "," *)) list (* zero or more *)
  * expression option
  * Token.t (* ")" *)
)

and assign_expression = (unary_expression * Token.t (* "=" *) * expression)

and binary_expression = [
    `Bin_oper_EQEQGT_bin_oper of (
        binary_operand * Token.t (* "==>" *) * binary_operand
    )
  | `Bin_oper_BARBAR_bin_oper of (
        binary_operand * Token.t (* "||" *) * binary_operand
    )
  | `Bin_oper_AMPAMP_bin_oper of (
        binary_operand * Token.t (* "&&" *) * binary_operand
    )
  | `Bin_oper_EQEQ_bin_oper of (
        binary_operand * Token.t (* "==" *) * binary_operand
    )
  | `Bin_oper_BANGEQ_bin_oper of (
        binary_operand * Token.t (* "!=" *) * binary_operand
    )
  | `Bin_oper_LT_bin_oper of (
        binary_operand * Token.t (* "<" *) * binary_operand
    )
  | `Bin_oper_GT_bin_oper of (
        binary_operand * Token.t (* ">" *) * binary_operand
    )
  | `Bin_oper_LTEQ_bin_oper of (
        binary_operand * Token.t (* "<=" *) * binary_operand
    )
  | `Bin_oper_GTEQ_bin_oper of (
        binary_operand * Token.t (* ">=" *) * binary_operand
    )
  | `Bin_oper_DOTDOT_bin_oper of (
        binary_operand * Token.t (* ".." *) * binary_operand
    )
  | `Bin_oper_BAR_bin_oper of (
        binary_operand * Token.t (* "|" *) * binary_operand
    )
  | `Bin_oper_HAT_bin_oper of (
        binary_operand * Token.t (* "^" *) * binary_operand
    )
  | `Bin_oper_AMP_bin_oper of (
        binary_operand * Token.t (* "&" *) * binary_operand
    )
  | `Bin_oper_LTLT_bin_oper of (
        binary_operand * Token.t (* "<<" *) * binary_operand
    )
  | `Bin_oper_GTGT_bin_oper of (
        binary_operand * Token.t (* ">>" *) * binary_operand
    )
  | `Bin_oper_PLUS_bin_oper of (
        binary_operand * Token.t (* "+" *) * binary_operand
    )
  | `Bin_oper_DASH_bin_oper of (
        binary_operand * Token.t (* "-" *) * binary_operand
    )
  | `Bin_oper_STAR_bin_oper of (
        binary_operand * Token.t (* "*" *) * binary_operand
    )
  | `Bin_oper_SLASH_bin_oper of (
        binary_operand * Token.t (* "/" *) * binary_operand
    )
  | `Bin_oper_PERC_bin_oper of (
        binary_operand * Token.t (* "%" *) * binary_operand
    )
]

and binary_operand = [
    `Un_exp of unary_expression
  | `Bin_exp of binary_expression
  | `Cast_exp of cast_expression
]

and bind = [
    `Opt_mut_var_id of (Token.t (* "mut" *) option * identifier (*tok*))
  | `Bind_unpack of (
        module_access
      * type_arguments option
      * bind_fields option
    )
  | `Var_id_AT_bind of (identifier (*tok*) * Token.t (* "@" *) * bind)
  | `Ellips of Token.t (* "..." *)
]

and bind_field = [
    `Choice_opt_mut_choice_exp_opt_COLON_bind of [
        `Opt_mut_choice_exp_opt_COLON_bind of (
            Token.t (* "mut" *) option
          * [ `Exp of expression ]
          * (Token.t (* ":" *) * bind) option
        )
      | `Spread_op of Token.t (* ".." *)
    ]
  | `Ellips of Token.t (* "..." *)
]

and bind_fields = [
    `Bind_posi_fields of (
        Token.t (* "(" *)
      * (bind_field * Token.t (* "," *)) list (* zero or more *)
      * bind_field option
      * Token.t (* ")" *)
    )
  | `Bind_named_fields of (
        Token.t (* "{" *)
      * (bind_field * Token.t (* "," *)) list (* zero or more *)
      * bind_field option
      * Token.t (* "}" *)
    )
]

and bind_list = [
    `Bind of bind
  | `LPAR_rep_bind_COMMA_opt_bind_RPAR of (
        Token.t (* "(" *)
      * (bind * Token.t (* "," *)) list (* zero or more *)
      * bind option
      * Token.t (* ")" *)
    )
]

and block = (
    Token.t (* "{" *)
  * use_declaration list (* zero or more *)
  * block_item list (* zero or more *)
  * expression option
  * Token.t (* "}" *)
)

and block_item = [
    `Choice_exp_SEMI of (semgrep_expression * Token.t (* ";" *))
  | `Ellips of Token.t (* "..." *)
]

and borrow_expression = (anon_choice_AMP_c6caa5d * expression)

and break_expression = (
    Token.t (* "break" *)
  * label option
  * expression_term option
)

and call_expression = (module_access * type_arguments option * arg_list)

and cast_expression = (expression * Token.t (* "as" *) * type_)

and deep_ellipsis = (
    Token.t (* "<..." *) * expression * Token.t (* "...>" *)
)

and dereference_expression = (Token.t (* "*" *) * expression)

and dot_or_index_chain = [
    `Choice_access_field of [
        `Access_field of access_field
      | `Rece_call of receiver_call
      | `Rece_macro_call of receiver_macro_call
      | `Index_exp of index_expression
      | `Exp_term of expression_term
    ]
  | `Field_access_ellips_expr of field_access_ellipsis_expr
]

and exp_field = [
    `Field_id_opt_COLON_exp of (
        identifier (*tok*)
      * (Token.t (* ":" *) * expression) option
    )
  | `Ellips of Token.t (* "..." *)
]

and expression = [
    `Choice_call_exp of [
        `Call_exp of call_expression
      | `Macro_call_exp of macro_call_expression
      | `Lambda_exp of lambda_expression
      | `If_exp of if_expression
      | `While_exp of while_expression
      | `Loop_exp of loop_expression
      | `Ret_exp of return_expression
      | `Abort_exp of abort_expression
      | `Assign_exp of assign_expression
      | `Un_exp of unary_expression
      | `Bin_exp of binary_expression
      | `Cast_exp of cast_expression
      | `Quan_exp of quantifier_expression
      | `Iden_exp of identified_expression
      | `Match_exp of match_expression
      | `Vec_exp of vector_expression
    ]
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips of deep_ellipsis
]

and expression_list = (
    Token.t (* "(" *)
  * expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and expression_term = [
    `Choice_brk_exp of [
        `Brk_exp of break_expression
      | `Cont_exp of continue_expression
      | `Name_exp of name_expression
      | `Call_exp of call_expression
      | `Macro_call_exp of macro_call_expression
      | `Pack_exp of pack_expression
      | `Lit_value of literal_value
      | `Unit_exp of unit_expression
      | `Exp_list of expression_list
      | `Anno_exp of annotation_expression
      | `Blk of block
      | `Spec_blk of spec_block
      | `If_exp of if_expression
      | `Vec_exp of vector_expression
      | `Match_exp of match_expression
    ]
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips of deep_ellipsis
  | `Typed_meta of (
        Token.t (* "(" *) * identifier (*tok*) * Token.t (* ":" *) * type_
      * Token.t (* ")" *)
    )
]

and field_access_ellipsis_expr = (
    dot_or_index_chain * Token.t (* "." *) * Token.t (* "..." *)
)

and field_initialize_list = (
    Token.t (* "{" *)
  * (exp_field * Token.t (* "," *)) list (* zero or more *)
  * exp_field option
  * Token.t (* "}" *)
)

and identified_expression = (block_identifier * expression)

and if_expression = (
    Token.t (* "if" *)
  * Token.t (* "(" *)
  * expression
  * Token.t (* ")" *)
  * expression
  * (Token.t (* "else" *) * expression) option
)

and index_expression = (
    dot_or_index_chain
  * Token.t (* "[" *)
  * (expression * Token.t (* "," *)) list (* zero or more *)
  * expression option
  * Token.t (* "]" *)
)

and lambda_bindings = (
    Token.t (* "|" *)
  * (bind * Token.t (* "," *)) list (* zero or more *)
  * bind option
  * Token.t (* "|" *)
)

and lambda_expression = (
    lambda_bindings
  * (Token.t (* "->" *) * type_) option
  * expression
)

and loop_expression = (Token.t (* "loop" *) * expression)

and macro_call_expression = (
    macro_module_access
  * type_arguments option
  * arg_list
)

and match_arm = (
    bind_list
  * (Token.t (* "if" *) * expression) option
  * Token.t (* "=>" *)
  * expression
)

and match_body = (
    Token.t (* "{" *)
  * (match_arm * Token.t (* "," *)) list (* zero or more *)
  * match_arm option
  * Token.t (* "}" *)
)

and match_expression = (
    Token.t (* "match" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *) * match_body
)

and move_or_copy_expression = (
    [ `Move of Token.t (* "move" *) | `Copy of Token.t (* "copy" *) ]
  * expression
)

and pack_expression = (
    module_access
  * type_arguments option
  * field_initialize_list
)

and quantifier_binding = [
    `Id_COLON_type of (identifier (*tok*) * Token.t (* ":" *) * type_)
  | `Id_in_exp of (identifier (*tok*) * Token.t (* "in" *) * expression)
]

and quantifier_bindings = (
    quantifier_binding
  * (Token.t (* "," *) * quantifier_binding) list (* zero or more *)
  * Token.t (* "," *) option
)

and quantifier_expression = (
    reserved_identifier
  * quantifier_bindings
  * (Token.t (* "where" *) * expression) option
  * Token.t (* ":" *)
  * expression
)

and receiver_call = (
    dot_or_index_chain * Token.t (* "." *) * identifier (*tok*) * arg_list
)

and receiver_macro_call = (
    dot_or_index_chain
  * Token.t (* "." *)
  * identifier (*tok*)
  * Token.t (* "!" *)
  * type_arguments option
  * arg_list
)

and return_expression = (
    Token.t (* "return" *)
  * label option
  * [ `Exp_term of expression_term | `Exp of expression ] option
)

and semgrep_expression = [
    `Exp of expression
  | `Let_stmt of (
        Token.t (* "let" *)
      * bind_list
      * ret_type option
      * (Token.t (* "=" *) * expression) option
    )
]

and spec_apply = (
    Token.t (* "apply" *)
  * expression
  * Token.t (* "to" *)
  * spec_apply_pattern
  * (Token.t (* "," *) * spec_apply_pattern) list (* zero or more *)
  * Token.t (* "," *) option
  * (
        Token.t (* "except" *)
      * spec_apply_pattern
      * (Token.t (* "," *) * spec_apply_pattern) list (* zero or more *)
      * Token.t (* "," *) option
    )
      option
  * Token.t (* ";" *)
)

and spec_block = (
    Token.t (* "spec" *)
  * [
        `Opt_spec_blk_target_spec_body of (
            spec_block_target option
          * spec_body
        )
      | `Spec_func of spec_function
    ]
)

and spec_block_memeber = [
    `Choice_spec_inva of [
        `Spec_inva of spec_invariant
      | `Spec_func of spec_function
      | `Spec_cond of spec_condition
      | `Spec_incl of spec_include
      | `Spec_apply of spec_apply
      | `Spec_pragma of spec_pragma
      | `Spec_var of spec_variable
      | `Spec_let of spec_let
    ]
  | `Ellips of Token.t (* "..." *)
]

and spec_body = (
    Token.t (* "{" *)
  * use_declaration list (* zero or more *)
  * spec_block_memeber list (* zero or more *)
  * Token.t (* "}" *)
)

and spec_condition = [
    `Spec_cond_ of (
        [
            `Spec_cond_kind of spec_condition_kind
          | `Requis_opt_module of (
                Token.t (* "requires" *)
              * Token.t (* "module" *) option
            )
        ]
      * condition_properties option
      * expression
      * Token.t (* ";" *)
    )
  | `Spec_abort_if of (
        Token.t (* "aborts_if" *)
      * condition_properties option
      * expression
      * (Token.t (* "with" *) * expression) option
      * Token.t (* ";" *)
    )
  | `Spec_abort_with_or_modifs of (
        [
            `Aborts_with of Token.t (* "aborts_with" *)
          | `Modifs of Token.t (* "modifies" *)
        ]
      * condition_properties option
      * expression
      * (Token.t (* "," *) * expression) list (* zero or more *)
      * Token.t (* "," *) option
      * Token.t (* ";" *)
    )
]

and spec_function = [
    `Native_spec_func of (
        Token.t (* "native" *) * Token.t (* "fun" *)
      * spec_function_signature * Token.t (* ";" *)
    )
  | `Usual_spec_func of (
        Token.t (* "fun" *) * spec_function_signature * block
    )
  | `Unin_spec_func of (
        Token.t (* "fun" *) * spec_function_signature * Token.t (* ";" *)
    )
]

and spec_include = (Token.t (* "include" *) * expression * Token.t (* ";" *))

and spec_invariant = (
    Token.t (* "invariant" *)
  * [
        `Update of Token.t (* "update" *)
      | `Pack of Token.t (* "pack" *)
      | `Unpack of Token.t (* "unpack" *)
      | `Module of Token.t (* "module" *)
    ]
      option
  * condition_properties option
  * expression
  * Token.t (* ";" *)
)

and spec_let = (
    Token.t (* "let" *)
  * Token.t (* "post" *) option
  * identifier (*tok*)
  * Token.t (* "=" *)
  * expression
  * Token.t (* ";" *)
)

and unary_expression = [
    `Choice_un_exp_ of [
        `Un_exp_ of unary_expression_
      | `Borrow_exp of borrow_expression
      | `Dere_exp of dereference_expression
      | `Move_or_copy_exp of move_or_copy_expression
      | `Exp_term of expression_term
      | `Choice_choice_access_field of dot_or_index_chain
    ]
  | `Ellips of Token.t (* "..." *)
  | `Deep_ellips of deep_ellipsis
  | `Field_access_ellips_expr of field_access_ellipsis_expr
]

and unary_expression_ = (unary_op * expression)

and vector_expression = (
    [
        `Vect of Token.t (* "vector[" *)
      | `Vect_type_rep_COMMA_type_opt_COMMA_GT_LBRACK of (
            Token.t (* "vector<" *)
          * type_
          * (Token.t (* "," *) * type_) list (* zero or more *)
          * Token.t (* "," *) option
          * Token.t (* ">" *)
          * Token.t (* "[" *)
        )
    ]
  * (expression * Token.t (* "," *)) list (* zero or more *)
  * expression option
  * Token.t (* "]" *)
)

and while_expression = (
    Token.t (* "while" *) * Token.t (* "(" *) * expression
  * Token.t (* ")" *) * expression
)

type constant = (
    Token.t (* "const" *) * identifier (*tok*) * Token.t (* ":" *) * type_
  * Token.t (* "=" *) * expression * Token.t (* ";" *)
)

type enum_item = [
  `Enum_defi of (
      Token.t (* "public" *) option
    * enum_signature
    * enum_variants
    * postfix_ability_decls option
  )
]

type function_item = [
    `Native_func_defi of (function_signature * Token.t (* ";" *))
  | `Macro_func_defi of (
        modifier option
      * Token.t (* "macro" *)
      * macro_signature
      * block
    )
  | `Func_defi of (function_signature * block)
]

type module_body = [
    `Choice_SEMI_rep_choice_use_decl_opt_RCURL of (
        [ `SEMI of Token.t (* ";" *) | `LCURL of Token.t (* "{" *) ]
      * [
            `Use_decl of use_declaration
          | `Friend_decl of friend_declaration
          | `Cst of constant
          | `Func_item of function_item
          | `Struct_item of struct_item
          | `Enum_item of enum_item
          | `Spec_blk of spec_block
        ]
          list (* zero or more *)
      * Token.t (* "}" *) option
    )
  | `Ellips of Token.t (* "..." *)
]

type semgrep_statement =
  [
      `Blk_item of block_item
    | `Use_decl of use_declaration
    | `Friend_decl of friend_declaration
    | `Cst of constant
    | `Func_item of function_item
    | `Struct_item of struct_item
    | `Enum_item of enum_item
    | `Spec_blk of spec_block
    | `Module_body of module_body
  ]
    list (* one or more *)

type module_definition = (
    Token.t (* "module" *) * module_identity * module_body
)

type source_file = [
    `Rep_module_defi of module_definition list (* zero or more *)
  | `Semg_exp of semgrep_expression
  | `Semg_stmt of semgrep_statement
  | `Semg_part of [
        `Func_sign of function_signature
      | `Struct_sign of struct_signature
      | `Enum_sign of enum_signature
    ]
]

type exists (* inlined *) = Token.t (* "exists" *)

type whitespace (* inlined *) = Token.t (* pattern \s *)

type spread_operator (* inlined *) = Token.t (* ".." *)

type ellipsis (* inlined *) = Token.t (* "..." *)

type newline (* inlined *) = [ ]

type forall (* inlined *) = Token.t (* "forall" *)

type macro_identifier (* inlined *) =
  Token.t (* pattern [a-zA-Z_][0-9a-zA-Z_]*! *)

type line_comment (* inlined *) = Token.t

type block_comment (* inlined *) = Token.t

type module_identifier (* inlined *) = identifier (*tok*)

type variable_identifier (* inlined *) = identifier (*tok*)

type type_parameter_identifier (* inlined *) = identifier (*tok*)

type enum_identifier (* inlined *) = identifier (*tok*)

type variant_identifier (* inlined *) = identifier (*tok*)

type function_identifier (* inlined *) = identifier (*tok*)

type field_identifier (* inlined *) = identifier (*tok*)

type type_identifier (* inlined *) = identifier (*tok*)

type struct_identifier (* inlined *) = identifier (*tok*)

type spec_block_target_fun (* inlined *) = (
    Token.t (* "fun" *) * identifier (*tok*)
)

type spec_block_target_struct (* inlined *) = (
    Token.t (* "struct" *) * identifier (*tok*)
)

type spec_block_target_schema (* inlined *) = (
    Token.t (* "schema" *)
  * identifier (*tok*)
  * type_parameters option
)

type native_struct_definition (* inlined *) = (
    Token.t (* "public" *) option
  * Token.t (* "native" *)
  * struct_signature
  * Token.t (* ";" *)
)

type positional_fields (* inlined *) = (
    Token.t (* "(" *)
  * (type_ * Token.t (* "," *)) list (* zero or more *)
  * type_ option
  * Token.t (* ")" *)
)

type typed_metavariable (* inlined *) = (
    Token.t (* "(" *) * identifier (*tok*) * Token.t (* ":" *) * type_
  * Token.t (* ")" *)
)

type named_fields (* inlined *) = (
    Token.t (* "{" *)
  * (field_annotation * Token.t (* "," *)) list (* zero or more *)
  * field_annotation option
  * Token.t (* "}" *)
)

type annotation (* inlined *) = (
    Token.t (* "#[" *)
  * annotation_item
  * (Token.t (* "," *) * annotation_item) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "]" *)
)

type struct_definition (* inlined *) = (
    Token.t (* "public" *) option
  * struct_signature
  * datatype_fields
  * postfix_ability_decls option
)

type uninterpreted_spec_function (* inlined *) = (
    Token.t (* "fun" *) * spec_function_signature * Token.t (* ";" *)
)

type native_spec_function (* inlined *) = (
    Token.t (* "native" *) * Token.t (* "fun" *) * spec_function_signature
  * Token.t (* ";" *)
)

type native_function_definition (* inlined *) = (
    function_signature * Token.t (* ";" *)
)

type semgrep_partial (* inlined *) = [
    `Func_sign of function_signature
  | `Struct_sign of struct_signature
  | `Enum_sign of enum_signature
]

type bind_named_fields (* inlined *) = (
    Token.t (* "{" *)
  * (bind_field * Token.t (* "," *)) list (* zero or more *)
  * bind_field option
  * Token.t (* "}" *)
)

type bind_positional_fields (* inlined *) = (
    Token.t (* "(" *)
  * (bind_field * Token.t (* "," *)) list (* zero or more *)
  * bind_field option
  * Token.t (* ")" *)
)

type bind_unpack (* inlined *) = (
    module_access
  * type_arguments option
  * bind_fields option
)

type let_statement (* inlined *) = (
    Token.t (* "let" *)
  * bind_list
  * ret_type option
  * (Token.t (* "=" *) * expression) option
)

type spec_abort_if (* inlined *) = (
    Token.t (* "aborts_if" *)
  * condition_properties option
  * expression
  * (Token.t (* "with" *) * expression) option
  * Token.t (* ";" *)
)

type spec_abort_with_or_modifies (* inlined *) = (
    [
        `Aborts_with of Token.t (* "aborts_with" *)
      | `Modifs of Token.t (* "modifies" *)
    ]
  * condition_properties option
  * expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ";" *)
)

type spec_condition_ (* inlined *) = (
    [
        `Spec_cond_kind of spec_condition_kind
      | `Requis_opt_module of (
            Token.t (* "requires" *)
          * Token.t (* "module" *) option
        )
    ]
  * condition_properties option
  * expression
  * Token.t (* ";" *)
)

type usual_spec_function (* inlined *) = (
    Token.t (* "fun" *) * spec_function_signature * block
)

type enum_definition (* inlined *) = (
    Token.t (* "public" *) option
  * enum_signature
  * enum_variants
  * postfix_ability_decls option
)

type function_definition (* inlined *) = (function_signature * block)

type macro_function_definition (* inlined *) = (
    modifier option
  * Token.t (* "macro" *)
  * macro_signature
  * block
)
