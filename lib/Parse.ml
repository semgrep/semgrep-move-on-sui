(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_move_on_sui"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "whitespace";
  "line_comment";
  "block_comment";
  "empty_line";
  "annotation";
]

let children_regexps : (string * Run.exp option) list = [
  "primitive_type",
  Some (
    Alt [|
      Token (Literal "u8");
      Token (Literal "u16");
      Token (Literal "u32");
      Token (Literal "u64");
      Token (Literal "u128");
      Token (Literal "u256");
      Token (Literal "bool");
      Token (Literal "address");
      Token (Literal "signer");
      Token (Literal "bytearray");
    |];
  );
  "byte_string_literal", None;
  "modifier",
  Some (
    Alt [|
      Token (Literal "public");
      Token (Literal "public(package)");
      Token (Literal "public(friend)");
      Token (Literal "entry");
      Token (Literal "native");
    |];
  );
  "exists", None;
  "address_literal", None;
  "identifier", None;
  "unary_op",
  Some (
    Alt [|
      Token (Literal "!");
    |];
  );
  "forall", None;
  "bool_literal",
  Some (
    Alt [|
      Token (Literal "true");
      Token (Literal "false");
    |];
  );
  "block_comment", None;
  "empty_line", None;
  "pat_3937285", None;
  "unit_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Literal ")");
    ];
  );
  "pat_2f1c977", None;
  "whitespace", None;
  "spec_condition_kind",
  Some (
    Alt [|
      Token (Literal "assert");
      Token (Literal "assume");
      Token (Literal "decreases");
      Token (Literal "ensures");
      Token (Literal "succeeds_if");
    |];
  );
  "ability",
  Some (
    Alt [|
      Token (Literal "copy");
      Token (Literal "drop");
      Token (Literal "store");
      Token (Literal "key");
    |];
  );
  "line_comment", None;
  "spec_apply_name_pattern", None;
  "hex_string_literal", None;
  "field_identifier", Some (Token (Name "identifier"););
  "module_identifier", Some (Token (Name "identifier"););
  "function_identifier", Some (Token (Name "identifier"););
  "variant_identifier", Some (Token (Name "identifier"););
  "struct_identifier", Some (Token (Name "identifier"););
  "variable_identifier", Some (Token (Name "identifier"););
  "enum_identifier", Some (Token (Name "identifier"););
  "use_member",
  Some (
    Alt [|
      Seq [
        Token (Name "identifier");
        Token (Literal "::");
        Token (Literal "{");
        Token (Name "use_member");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "use_member");
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal "}");
      ];
      Seq [
        Token (Name "identifier");
        Token (Literal "::");
        Token (Name "identifier");
        Opt (
          Seq [
            Token (Literal "as");
            Token (Name "identifier");
          ];
        );
      ];
      Seq [
        Token (Name "identifier");
        Opt (
          Seq [
            Token (Literal "as");
            Token (Name "identifier");
          ];
        );
      ];
    |];
  );
  "label",
  Some (
    Seq [
      Token (Literal "'");
      Token (Name "identifier");
    ];
  );
  "type_parameter_identifier",
  Some (
    Token (Name "identifier");
  );
  "reserved_identifier",
  Some (
    Alt [|
      Token (Name "forall");
      Token (Name "exists");
    |];
  );
  "num_literal",
  Some (
    Alt [|
      Token (Name "pat_3937285");
      Token (Name "pat_2f1c977");
    |];
  );
  "ability_decls",
  Some (
    Seq [
      Token (Literal "has");
      Repeat (
        Seq [
          Token (Name "ability");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "ability");
      );
    ];
  );
  "postfix_ability_decls",
  Some (
    Seq [
      Token (Literal "has");
      Repeat (
        Seq [
          Token (Name "ability");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "ability");
      );
      Token (Literal ";");
    ];
  );
  "move_or_copy_expression",
  Some (
    Seq [
      Alt [|
        Token (Literal "move");
        Token (Literal "copy");
      |];
      Token (Name "variable_identifier");
    ];
  );
  "continue_expression",
  Some (
    Seq [
      Token (Literal "continue");
      Opt (
        Token (Name "label");
      );
    ];
  );
  "block_identifier",
  Some (
    Seq [
      Token (Name "label");
      Token (Literal ":");
    ];
  );
  "type_parameter",
  Some (
    Seq [
      Opt (
        Token (Literal "$");
      );
      Opt (
        Token (Literal "phantom");
      );
      Token (Name "type_parameter_identifier");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "ability");
          Repeat (
            Seq [
              Token (Literal "+");
              Token (Name "ability");
            ];
          );
          Opt (
            Token (Literal "+");
          );
        ];
      );
    ];
  );
  "module_identity",
  Some (
    Seq [
      Alt [|
        Token (Name "num_literal");
        Token (Name "module_identifier");
      |];
      Token (Literal "::");
      Token (Name "module_identifier");
    ];
  );
  "literal_value",
  Some (
    Alt [|
      Token (Name "address_literal");
      Token (Name "bool_literal");
      Token (Name "num_literal");
      Token (Name "hex_string_literal");
      Token (Name "byte_string_literal");
    |];
  );
  "type_parameters",
  Some (
    Seq [
      Token (Literal "<");
      Token (Name "type_parameter");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type_parameter");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ">");
    ];
  );
  "friend_access",
  Some (
    Alt [|
      Token (Name "identifier");
      Token (Name "module_identity");
    |];
  );
  "use_module",
  Some (
    Seq [
      Token (Name "module_identity");
      Opt (
        Seq [
          Token (Literal "as");
          Token (Name "module_identifier");
        ];
      );
    ];
  );
  "use_module_members",
  Some (
    Alt [|
      Seq [
        Alt [|
          Token (Name "num_literal");
          Token (Name "module_identifier");
        |];
        Token (Literal "::");
        Token (Literal "{");
        Token (Name "use_member");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "use_member");
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal "}");
      ];
      Seq [
        Token (Name "module_identity");
        Token (Literal "::");
        Token (Literal "{");
        Token (Name "use_member");
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "use_member");
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal "}");
      ];
    |];
  );
  "use_module_member",
  Some (
    Seq [
      Token (Name "module_identity");
      Token (Literal "::");
      Token (Name "use_member");
    ];
  );
  "module_access",
  Some (
    Alt [|
      Seq [
        Token (Literal "$");
        Token (Name "identifier");
      ];
      Token (Name "reserved_identifier");
      Token (Name "identifier");
      Seq [
        Token (Name "module_identifier");
        Token (Literal "::");
        Token (Name "identifier");
      ];
      Seq [
        Token (Name "module_identity");
        Token (Literal "::");
        Token (Name "identifier");
      ];
    |];
  );
  "spec_property",
  Some (
    Seq [
      Token (Name "identifier");
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "literal_value");
        ];
      );
    ];
  );
  "struct_signature",
  Some (
    Seq [
      Token (Literal "struct");
      Token (Name "struct_identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Opt (
        Token (Name "ability_decls");
      );
    ];
  );
  "spec_block_target_schema",
  Some (
    Seq [
      Token (Literal "schema");
      Token (Name "struct_identifier");
      Opt (
        Token (Name "type_parameters");
      );
    ];
  );
  "enum_signature",
  Some (
    Seq [
      Token (Literal "enum");
      Token (Name "enum_identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Opt (
        Token (Name "ability_decls");
      );
    ];
  );
  "spec_apply_pattern",
  Some (
    Seq [
      Opt (
        Alt [|
          Token (Literal "public");
          Token (Literal "internal");
        |];
      );
      Token (Name "spec_apply_name_pattern");
      Opt (
        Token (Name "type_parameters");
      );
    ];
  );
  "friend_declaration",
  Some (
    Seq [
      Token (Literal "friend");
      Token (Name "friend_access");
      Token (Literal ";");
    ];
  );
  "use_fun",
  Some (
    Seq [
      Token (Literal "fun");
      Token (Name "module_access");
      Token (Literal "as");
      Token (Name "module_access");
      Token (Literal ".");
      Token (Name "function_identifier");
    ];
  );
  "apply_type",
  Some (
    Seq [
      Token (Name "module_access");
      Opt (
        Token (Name "type_arguments");
      );
    ];
  );
  "function_type",
  Some (
    Seq [
      Token (Name "function_type_parameters");
      Opt (
        Seq [
          Token (Literal "->");
          Token (Name "type");
        ];
      );
    ];
  );
  "function_type_parameters",
  Some (
    Seq [
      Token (Literal "|");
      Repeat (
        Seq [
          Token (Name "type");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "type");
      );
      Token (Literal "|");
    ];
  );
  "ref_type",
  Some (
    Seq [
      Alt [|
        Token (Literal "&");
        Token (Literal "&mut");
      |];
      Token (Name "type");
    ];
  );
  "tuple_type",
  Some (
    Seq [
      Token (Literal "(");
      Repeat (
        Seq [
          Token (Name "type");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "type");
      );
      Token (Literal ")");
    ];
  );
  "type",
  Some (
    Alt [|
      Token (Name "apply_type");
      Token (Name "ref_type");
      Token (Name "tuple_type");
      Token (Name "function_type");
      Token (Name "primitive_type");
    |];
  );
  "type_arguments",
  Some (
    Seq [
      Token (Literal "<");
      Token (Name "type");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "type");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ">");
    ];
  );
  "annotation_item",
  Some (
    Alt [|
      Token (Name "identifier");
      Seq [
        Token (Name "identifier");
        Token (Literal "=");
        Token (Name "literal_value");
      ];
      Seq [
        Token (Name "identifier");
        Token (Literal "(");
        Alt [|
          Token (Name "literal_value");
          Token (Name "module_access");
        |];
        Repeat (
          Seq [
            Token (Literal ",");
            Alt [|
              Token (Name "literal_value");
              Token (Name "module_access");
            |];
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal ")");
      ];
      Seq [
        Token (Name "identifier");
        Token (Literal "(");
        Token (Name "identifier");
        Token (Literal "=");
        Alt [|
          Token (Name "module_access");
          Token (Name "literal_value");
        |];
        Repeat (
          Seq [
            Token (Literal ",");
            Token (Name "identifier");
            Token (Literal "=");
            Alt [|
              Token (Name "module_access");
              Token (Name "literal_value");
            |];
          ];
        );
        Opt (
          Token (Literal ",");
        );
        Token (Literal ")");
      ];
    |];
  );
  "macro_module_access",
  Some (
    Seq [
      Token (Name "module_access");
      Token (Literal "!");
    ];
  );
  "condition_properties",
  Some (
    Seq [
      Token (Literal "[");
      Repeat (
        Seq [
          Token (Name "spec_property");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "spec_property");
      );
      Token (Literal "]");
    ];
  );
  "spec_pragma",
  Some (
    Seq [
      Token (Literal "pragma");
      Repeat (
        Seq [
          Token (Name "spec_property");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "spec_property");
      );
      Token (Literal ";");
    ];
  );
  "native_struct_definition",
  Some (
    Seq [
      Opt (
        Token (Literal "public");
      );
      Token (Literal "native");
      Token (Name "struct_signature");
      Token (Literal ";");
    ];
  );
  "spec_block_target",
  Some (
    Alt [|
      Token (Name "identifier");
      Token (Literal "module");
      Token (Name "spec_block_target_schema");
    |];
  );
  "use_declaration",
  Some (
    Seq [
      Opt (
        Token (Literal "public");
      );
      Token (Literal "use");
      Alt [|
        Token (Name "use_fun");
        Token (Name "use_module");
        Token (Name "use_module_member");
        Token (Name "use_module_members");
      |];
      Token (Literal ";");
    ];
  );
  "name_expression",
  Some (
    Seq [
      Token (Name "module_access");
      Opt (
        Token (Name "type_arguments");
      );
    ];
  );
  "field_annotation",
  Some (
    Seq [
      Token (Name "field_identifier");
      Token (Literal ":");
      Token (Name "type");
    ];
  );
  "spec_variable",
  Some (
    Seq [
      Opt (
        Alt [|
          Token (Literal "global");
          Token (Literal "local");
        |];
      );
      Token (Name "identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Token (Literal ":");
      Token (Name "type");
      Token (Literal ";");
    ];
  );
  "function_parameter",
  Some (
    Seq [
      Opt (
        Token (Literal "mut");
      );
      Alt [|
        Token (Name "variable_identifier");
        Seq [
          Token (Literal "$");
          Token (Name "variable_identifier");
        ];
      |];
      Token (Literal ":");
      Token (Name "type");
    ];
  );
  "positional_fields",
  Some (
    Seq [
      Token (Literal "(");
      Repeat (
        Seq [
          Token (Name "type");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "type");
      );
      Token (Literal ")");
    ];
  );
  "ret_type",
  Some (
    Seq [
      Token (Literal ":");
      Token (Name "type");
    ];
  );
  "bind",
  Some (
    Alt [|
      Seq [
        Opt (
          Token (Literal "mut");
        );
        Token (Name "variable_identifier");
      ];
      Token (Name "bind_unpack");
      Seq [
        Token (Name "variable_identifier");
        Token (Literal "@");
        Token (Name "bind");
      ];
    |];
  );
  "bind_field",
  Some (
    Seq [
      Opt (
        Token (Literal "mut");
      );
      Token (Name "field_identifier");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "bind");
        ];
      );
    ];
  );
  "bind_fields",
  Some (
    Alt [|
      Token (Name "bind_positional_fields");
      Token (Name "bind_named_fields");
    |];
  );
  "bind_named_fields",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Seq [
          Token (Name "bind_field");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "bind_field");
      );
      Token (Literal "}");
    ];
  );
  "bind_positional_fields",
  Some (
    Seq [
      Token (Literal "(");
      Repeat (
        Seq [
          Token (Name "bind_field");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "bind_field");
      );
      Token (Literal ")");
    ];
  );
  "bind_unpack",
  Some (
    Seq [
      Token (Name "module_access");
      Opt (
        Token (Name "type_arguments");
      );
      Opt (
        Token (Name "bind_fields");
      );
    ];
  );
  "annotation",
  Some (
    Seq [
      Token (Literal "#[");
      Token (Name "annotation_item");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "annotation_item");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "]");
    ];
  );
  "named_fields",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Seq [
          Token (Name "field_annotation");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "field_annotation");
      );
      Token (Literal "}");
    ];
  );
  "function_parameters",
  Some (
    Seq [
      Token (Literal "(");
      Repeat (
        Seq [
          Token (Name "function_parameter");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "function_parameter");
      );
      Token (Literal ")");
    ];
  );
  "bind_list",
  Some (
    Alt [|
      Token (Name "bind");
      Seq [
        Token (Literal "(");
        Repeat (
          Seq [
            Token (Name "bind");
            Token (Literal ",");
          ];
        );
        Opt (
          Token (Name "bind");
        );
        Token (Literal ")");
      ];
    |];
  );
  "lambda_bindings",
  Some (
    Seq [
      Token (Literal "|");
      Repeat (
        Seq [
          Token (Name "bind");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "bind");
      );
      Token (Literal "|");
    ];
  );
  "datatype_fields",
  Some (
    Alt [|
      Token (Name "positional_fields");
      Token (Name "named_fields");
    |];
  );
  "function_signature",
  Some (
    Seq [
      Opt (
        Token (Name "modifier");
      );
      Opt (
        Token (Name "modifier");
      );
      Token (Literal "fun");
      Token (Name "function_identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Token (Name "function_parameters");
      Opt (
        Token (Name "ret_type");
      );
    ];
  );
  "spec_function_signature",
  Some (
    Seq [
      Token (Name "function_identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Token (Name "function_parameters");
      Token (Name "ret_type");
    ];
  );
  "macro_signature",
  Some (
    Seq [
      Opt (
        Token (Name "modifier");
      );
      Token (Literal "fun");
      Token (Name "function_identifier");
      Opt (
        Token (Name "type_parameters");
      );
      Token (Name "function_parameters");
      Opt (
        Token (Name "ret_type");
      );
    ];
  );
  "struct_definition",
  Some (
    Seq [
      Opt (
        Token (Literal "public");
      );
      Token (Name "struct_signature");
      Token (Name "datatype_fields");
      Opt (
        Token (Name "postfix_ability_decls");
      );
    ];
  );
  "variant",
  Some (
    Seq [
      Token (Name "variant_identifier");
      Opt (
        Token (Name "datatype_fields");
      );
    ];
  );
  "native_function_definition",
  Some (
    Seq [
      Token (Name "function_signature");
      Token (Literal ";");
    ];
  );
  "native_spec_function",
  Some (
    Seq [
      Token (Literal "native");
      Token (Literal "fun");
      Token (Name "spec_function_signature");
      Token (Literal ";");
    ];
  );
  "uninterpreted_spec_function",
  Some (
    Seq [
      Token (Literal "fun");
      Token (Name "spec_function_signature");
      Token (Literal ";");
    ];
  );
  "struct_item",
  Some (
    Alt [|
      Token (Name "native_struct_definition");
      Token (Name "struct_definition");
    |];
  );
  "enum_variants",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Seq [
          Token (Name "variant");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "variant");
      );
      Token (Literal "}");
    ];
  );
  "abort_expression",
  Some (
    Seq [
      Token (Literal "abort");
      Token (Name "expression");
    ];
  );
  "annotate_expression",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ":");
      Token (Name "type");
      Token (Literal ")");
    ];
  );
  "arg_list",
  Some (
    Seq [
      Token (Literal "(");
      Repeat (
        Seq [
          Token (Name "expression");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "expression");
      );
      Token (Literal ")");
    ];
  );
  "assign_expression",
  Some (
    Seq [
      Token (Name "unary_expression");
      Token (Literal "=");
      Token (Name "expression");
    ];
  );
  "binary_expression",
  Some (
    Alt [|
      Seq [
        Token (Name "binary_operand");
        Token (Literal "==>");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "||");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "&&");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "==");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "!=");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "<");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal ">");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "<=");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal ">=");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "..");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "|");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "^");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "&");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "<<");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal ">>");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "+");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "-");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "*");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "/");
        Token (Name "binary_operand");
      ];
      Seq [
        Token (Name "binary_operand");
        Token (Literal "%");
        Token (Name "binary_operand");
      ];
    |];
  );
  "binary_operand",
  Some (
    Alt [|
      Token (Name "unary_expression");
      Token (Name "binary_expression");
      Token (Name "cast_expression");
    |];
  );
  "block",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "use_declaration");
      );
      Repeat (
        Token (Name "block_item");
      );
      Opt (
        Token (Name "expression");
      );
      Token (Literal "}");
    ];
  );
  "block_item",
  Some (
    Seq [
      Alt [|
        Token (Name "expression");
        Token (Name "let_statement");
      |];
      Token (Literal ";");
    ];
  );
  "borrow_expression",
  Some (
    Seq [
      Alt [|
        Token (Literal "&");
        Token (Literal "&mut");
      |];
      Token (Name "expression");
    ];
  );
  "break_expression",
  Some (
    Seq [
      Token (Literal "break");
      Opt (
        Token (Name "label");
      );
      Opt (
        Token (Name "expression_term");
      );
    ];
  );
  "call_expression",
  Some (
    Seq [
      Token (Name "module_access");
      Opt (
        Token (Name "type_arguments");
      );
      Token (Name "arg_list");
    ];
  );
  "cast_expression",
  Some (
    Seq [
      Token (Name "expression");
      Token (Literal "as");
      Token (Name "type");
    ];
  );
  "dereference_expression",
  Some (
    Seq [
      Token (Literal "*");
      Token (Name "expression");
    ];
  );
  "dot_expression",
  Some (
    Seq [
      Token (Name "expression_term");
      Token (Literal ".");
      Token (Name "expression_term");
    ];
  );
  "exp_field",
  Some (
    Seq [
      Token (Name "field_identifier");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "expression");
        ];
      );
    ];
  );
  "expression",
  Some (
    Alt [|
      Token (Name "lambda_expression");
      Token (Name "if_expression");
      Token (Name "while_expression");
      Token (Name "loop_expression");
      Token (Name "return_expression");
      Token (Name "abort_expression");
      Token (Name "assign_expression");
      Token (Name "unary_expression");
      Token (Name "binary_expression");
      Token (Name "cast_expression");
      Token (Name "quantifier_expression");
      Token (Name "identified_expression");
      Token (Name "match_expression");
      Token (Name "vector_expression");
    |];
  );
  "expression_list",
  Some (
    Seq [
      Token (Literal "(");
      Token (Name "expression");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "expression");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ")");
    ];
  );
  "expression_term",
  Some (
    Alt [|
      Token (Name "break_expression");
      Token (Name "continue_expression");
      Token (Name "name_expression");
      Token (Name "call_expression");
      Token (Name "macro_call_expression");
      Token (Name "pack_expression");
      Token (Name "literal_value");
      Token (Name "unit_expression");
      Token (Name "expression_list");
      Token (Name "annotate_expression");
      Token (Name "block");
      Token (Name "spec_block");
      Token (Name "if_expression");
      Token (Name "dot_expression");
      Token (Name "index_expression");
    |];
  );
  "field_initialize_list",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Seq [
          Token (Name "exp_field");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "exp_field");
      );
      Token (Literal "}");
    ];
  );
  "identified_expression",
  Some (
    Seq [
      Token (Name "block_identifier");
      Token (Name "expression");
    ];
  );
  "if_expression",
  Some (
    Seq [
      Token (Literal "if");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "expression");
      Opt (
        Seq [
          Token (Literal "else");
          Token (Name "expression");
        ];
      );
    ];
  );
  "index_expression",
  Some (
    Seq [
      Token (Name "expression_term");
      Token (Literal "[");
      Token (Name "expression");
      Token (Literal "]");
    ];
  );
  "lambda_expression",
  Some (
    Seq [
      Token (Name "lambda_bindings");
      Opt (
        Seq [
          Token (Literal "->");
          Token (Name "type");
        ];
      );
      Token (Name "expression");
    ];
  );
  "let_statement",
  Some (
    Seq [
      Token (Literal "let");
      Token (Name "bind_list");
      Opt (
        Seq [
          Token (Literal ":");
          Token (Name "type");
        ];
      );
      Opt (
        Seq [
          Token (Literal "=");
          Token (Name "expression");
        ];
      );
    ];
  );
  "loop_expression",
  Some (
    Seq [
      Token (Literal "loop");
      Token (Name "expression");
    ];
  );
  "macro_call_expression",
  Some (
    Seq [
      Token (Name "macro_module_access");
      Opt (
        Token (Name "type_arguments");
      );
      Token (Name "arg_list");
    ];
  );
  "match_arm",
  Some (
    Seq [
      Token (Name "bind_list");
      Opt (
        Seq [
          Token (Literal "if");
          Token (Name "expression");
        ];
      );
      Token (Literal "=>");
      Token (Name "expression");
    ];
  );
  "match_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Seq [
          Token (Name "match_arm");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "match_arm");
      );
      Token (Literal "}");
    ];
  );
  "match_expression",
  Some (
    Seq [
      Token (Literal "match");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "match_body");
    ];
  );
  "pack_expression",
  Some (
    Seq [
      Token (Name "module_access");
      Opt (
        Token (Name "type_arguments");
      );
      Token (Name "field_initialize_list");
    ];
  );
  "quantifier_binding",
  Some (
    Alt [|
      Seq [
        Token (Name "identifier");
        Token (Literal ":");
        Token (Name "type");
      ];
      Seq [
        Token (Name "identifier");
        Token (Literal "in");
        Token (Name "expression");
      ];
    |];
  );
  "quantifier_bindings",
  Some (
    Seq [
      Token (Name "quantifier_binding");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "quantifier_binding");
        ];
      );
      Opt (
        Token (Literal ",");
      );
    ];
  );
  "quantifier_expression",
  Some (
    Seq [
      Alt [|
        Token (Name "forall");
        Token (Name "exists");
      |];
      Token (Name "quantifier_bindings");
      Opt (
        Seq [
          Token (Literal "where");
          Token (Name "expression");
        ];
      );
      Token (Literal ":");
      Token (Name "expression");
    ];
  );
  "return_expression",
  Some (
    Seq [
      Token (Literal "return");
      Opt (
        Token (Name "label");
      );
      Opt (
        Alt [|
          Token (Name "expression_term");
          Token (Name "expression");
        |];
      );
    ];
  );
  "spec_abort_if",
  Some (
    Seq [
      Token (Literal "aborts_if");
      Opt (
        Token (Name "condition_properties");
      );
      Token (Name "expression");
      Opt (
        Seq [
          Token (Literal "with");
          Token (Name "expression");
        ];
      );
      Token (Literal ";");
    ];
  );
  "spec_abort_with_or_modifies",
  Some (
    Seq [
      Alt [|
        Token (Literal "aborts_with");
        Token (Literal "modifies");
      |];
      Opt (
        Token (Name "condition_properties");
      );
      Token (Name "expression");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "expression");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal ";");
    ];
  );
  "spec_apply",
  Some (
    Seq [
      Token (Literal "apply");
      Token (Name "expression");
      Token (Literal "to");
      Token (Name "spec_apply_pattern");
      Repeat (
        Seq [
          Token (Literal ",");
          Token (Name "spec_apply_pattern");
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Opt (
        Seq [
          Token (Literal "except");
          Token (Name "spec_apply_pattern");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "spec_apply_pattern");
            ];
          );
          Opt (
            Token (Literal ",");
          );
        ];
      );
      Token (Literal ";");
    ];
  );
  "spec_block",
  Some (
    Seq [
      Token (Literal "spec");
      Alt [|
        Seq [
          Opt (
            Token (Name "spec_block_target");
          );
          Token (Name "spec_body");
        ];
        Token (Name "spec_function");
      |];
    ];
  );
  "spec_block_memeber",
  Some (
    Alt [|
      Token (Name "spec_invariant");
      Token (Name "spec_function");
      Token (Name "spec_condition");
      Token (Name "spec_include");
      Token (Name "spec_apply");
      Token (Name "spec_pragma");
      Token (Name "spec_variable");
      Token (Name "spec_let");
    |];
  );
  "spec_body",
  Some (
    Seq [
      Token (Literal "{");
      Repeat (
        Token (Name "use_declaration");
      );
      Repeat (
        Token (Name "spec_block_memeber");
      );
      Token (Literal "}");
    ];
  );
  "spec_condition",
  Some (
    Alt [|
      Token (Name "spec_condition_");
      Token (Name "spec_abort_if");
      Token (Name "spec_abort_with_or_modifies");
    |];
  );
  "spec_condition_",
  Some (
    Seq [
      Alt [|
        Token (Name "spec_condition_kind");
        Seq [
          Token (Literal "requires");
          Opt (
            Token (Literal "module");
          );
        ];
      |];
      Opt (
        Token (Name "condition_properties");
      );
      Token (Name "expression");
      Token (Literal ";");
    ];
  );
  "spec_function",
  Some (
    Alt [|
      Token (Name "native_spec_function");
      Token (Name "usual_spec_function");
      Token (Name "uninterpreted_spec_function");
    |];
  );
  "spec_include",
  Some (
    Seq [
      Token (Literal "include");
      Token (Name "expression");
      Token (Literal ";");
    ];
  );
  "spec_invariant",
  Some (
    Seq [
      Token (Literal "invariant");
      Opt (
        Alt [|
          Token (Literal "update");
          Token (Literal "pack");
          Token (Literal "unpack");
          Token (Literal "module");
        |];
      );
      Opt (
        Token (Name "condition_properties");
      );
      Token (Name "expression");
      Token (Literal ";");
    ];
  );
  "spec_let",
  Some (
    Seq [
      Token (Literal "let");
      Opt (
        Token (Literal "post");
      );
      Token (Name "identifier");
      Token (Literal "=");
      Token (Name "expression");
      Token (Literal ";");
    ];
  );
  "unary_expression",
  Some (
    Alt [|
      Token (Name "unary_expression_");
      Token (Name "borrow_expression");
      Token (Name "dereference_expression");
      Token (Name "move_or_copy_expression");
      Token (Name "expression_term");
    |];
  );
  "unary_expression_",
  Some (
    Seq [
      Token (Name "unary_op");
      Token (Name "expression");
    ];
  );
  "usual_spec_function",
  Some (
    Seq [
      Token (Literal "fun");
      Token (Name "spec_function_signature");
      Token (Name "block");
    ];
  );
  "vector_expression",
  Some (
    Seq [
      Alt [|
        Token (Literal "vector[");
        Seq [
          Token (Literal "vector<");
          Token (Name "type");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "type");
            ];
          );
          Opt (
            Token (Literal ",");
          );
          Token (Literal ">");
          Token (Literal "[");
        ];
      |];
      Repeat (
        Seq [
          Token (Name "expression");
          Token (Literal ",");
        ];
      );
      Opt (
        Token (Name "expression");
      );
      Token (Literal "]");
    ];
  );
  "while_expression",
  Some (
    Seq [
      Token (Literal "while");
      Token (Literal "(");
      Token (Name "expression");
      Token (Literal ")");
      Token (Name "expression");
    ];
  );
  "enum_definition",
  Some (
    Seq [
      Opt (
        Token (Literal "public");
      );
      Token (Name "enum_signature");
      Token (Name "enum_variants");
      Opt (
        Token (Name "postfix_ability_decls");
      );
    ];
  );
  "constant",
  Some (
    Seq [
      Token (Literal "const");
      Token (Name "identifier");
      Token (Literal ":");
      Token (Name "type");
      Token (Literal "=");
      Token (Name "expression");
      Token (Literal ";");
    ];
  );
  "macro_function_definition",
  Some (
    Seq [
      Opt (
        Token (Name "modifier");
      );
      Token (Literal "macro");
      Token (Name "macro_signature");
      Token (Name "block");
    ];
  );
  "function_definition",
  Some (
    Seq [
      Token (Name "function_signature");
      Token (Name "block");
    ];
  );
  "enum_item",
  Some (
    Alt [|
      Token (Name "enum_definition");
    |];
  );
  "function_item",
  Some (
    Alt [|
      Token (Name "native_function_definition");
      Token (Name "macro_function_definition");
      Token (Name "function_definition");
    |];
  );
  "module_body",
  Some (
    Seq [
      Alt [|
        Token (Literal ";");
        Token (Literal "{");
      |];
      Repeat (
        Alt [|
          Token (Name "use_declaration");
          Token (Name "friend_declaration");
          Token (Name "constant");
          Token (Name "function_item");
          Token (Name "struct_item");
          Token (Name "enum_item");
          Token (Name "spec_block");
        |];
      );
      Opt (
        Token (Literal "}");
      );
    ];
  );
  "module_definition",
  Some (
    Seq [
      Token (Literal "module");
      Token (Name "module_identity");
      Token (Name "module_body");
    ];
  );
  "source_file",
  Some (
    Repeat (
      Token (Name "module_definition");
    );
  );
]

let trans_primitive_type ((kind, body) : mt) : CST.primitive_type =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `U8 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `U16 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `U32 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `U64 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `U128 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `U256 (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Bool (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Addr (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Signer (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Byte (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_byte_string_literal ((kind, body) : mt) : CST.byte_string_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_modifier ((kind, body) : mt) : CST.modifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Public (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Publ_83d19bc (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Publ_7c2e49a (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Entry (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Native (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_exists ((kind, body) : mt) : CST.exists =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_address_literal ((kind, body) : mt) : CST.address_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_unary_op ((kind, body) : mt) : CST.unary_op =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `BANG (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_forall ((kind, body) : mt) : CST.forall =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_bool_literal ((kind, body) : mt) : CST.bool_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `True (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `False (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_block_comment ((kind, body) : mt) : CST.block_comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_empty_line ((kind, body) : mt) : CST.empty_line =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_3937285 ((kind, body) : mt) : CST.pat_3937285 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_unit_expression ((kind, body) : mt) : CST.unit_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_pat_2f1c977 ((kind, body) : mt) : CST.pat_2f1c977 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_whitespace ((kind, body) : mt) : CST.whitespace =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_spec_condition_kind ((kind, body) : mt) : CST.spec_condition_kind =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Assert (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Assume (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Decres (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Ensures (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Succes_if (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false


let trans_ability ((kind, body) : mt) : CST.ability =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Copy (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Drop (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Store (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Key (
            Run.trans_token (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_line_comment ((kind, body) : mt) : CST.line_comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_spec_apply_name_pattern ((kind, body) : mt) : CST.spec_apply_name_pattern =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_hex_string_literal ((kind, body) : mt) : CST.hex_string_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_field_identifier ((kind, body) : mt) : CST.field_identifier =
  match body with
  | Children v ->
      trans_identifier (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_module_identifier ((kind, body) : mt) : CST.module_identifier =
  match body with
  | Children v ->
      trans_identifier (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_function_identifier ((kind, body) : mt) : CST.function_identifier =
  match body with
  | Children v ->
      trans_identifier (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_variant_identifier ((kind, body) : mt) : CST.variant_identifier =
  match body with
  | Children v ->
      trans_identifier (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_struct_identifier ((kind, body) : mt) : CST.struct_identifier =
  match body with
  | Children v ->
      trans_identifier (Run.matcher_token v)
  | Leaf _ -> assert false


let trans_variable_identifier ((kind, body) : mt) : CST.variable_identifier =
  match body with
  | Children v ->
      trans_identifier (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_enum_identifier ((kind, body) : mt) : CST.enum_identifier =
  match body with
  | Children v ->
      trans_identifier (Run.matcher_token v)
  | Leaf _ -> assert false

let rec trans_use_member ((kind, body) : mt) : CST.use_member =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id_COLONCOLON_LCURL_use_member_rep_COMMA_use_member_opt_COMMA_RCURL (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_use_member (Run.matcher_token v3),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_use_member (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v4
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v5
                  ,
                  Run.trans_token (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Id_COLONCOLON_id_opt_as_id (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_identifier (Run.matcher_token v2),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_identifier (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Id_opt_as_id (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_identifier (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_label ((kind, body) : mt) : CST.label =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_parameter_identifier ((kind, body) : mt) : CST.type_parameter_identifier =
  match body with
  | Children v ->
      trans_identifier (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_reserved_identifier ((kind, body) : mt) : CST.reserved_identifier =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Forall (
            trans_forall (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Exists (
            trans_exists (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_num_literal ((kind, body) : mt) : CST.num_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Pat_3937285 (
            trans_pat_3937285 (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Pat_2f1c977 (
            trans_pat_2f1c977 (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_ability_decls ((kind, body) : mt) : CST.ability_decls =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_ability (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_ability (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_postfix_ability_decls ((kind, body) : mt) : CST.postfix_ability_decls =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_ability (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_ability (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false



let trans_move_or_copy_expression ((kind, body) : mt) : CST.move_or_copy_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Move (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Copy (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_variable_identifier (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_continue_expression ((kind, body) : mt) : CST.continue_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_label (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_block_identifier ((kind, body) : mt) : CST.block_identifier =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_label (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_parameter ((kind, body) : mt) : CST.type_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            trans_type_parameter_identifier (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_ability (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_ability (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v3
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_module_identity ((kind, body) : mt) : CST.module_identity =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Num_lit (
                  trans_num_literal (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Module_id (
                  trans_module_identifier (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_module_identifier (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_literal_value ((kind, body) : mt) : CST.literal_value =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Addr_lit (
            trans_address_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bool_lit (
            trans_bool_literal (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Num_lit (
            trans_num_literal (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Hex_str_lit (
            trans_hex_string_literal (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Byte_str_lit (
            trans_byte_string_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_type_parameters ((kind, body) : mt) : CST.type_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_parameter (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_friend_access ((kind, body) : mt) : CST.friend_access =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Module_iden (
            trans_module_identity (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_use_module ((kind, body) : mt) : CST.use_module =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_module_identity (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_module_identifier (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_use_module_members ((kind, body) : mt) : CST.use_module_members =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_num_lit_COLONCOLON_LCURL_use_member_rep_COMMA_use_member_opt_COMMA_RCURL (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  (match v0 with
                  | Alt (0, v) ->
                      `Num_lit (
                        trans_num_literal (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Module_id (
                        trans_module_identifier (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.trans_token (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_use_member (Run.matcher_token v3),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_use_member (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v4
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v5
                  ,
                  Run.trans_token (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Module_iden_COLONCOLON_LCURL_use_member_rep_COMMA_use_member_opt_COMMA_RCURL (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6] ->
                (
                  trans_module_identity (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_use_member (Run.matcher_token v3),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_use_member (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v4
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v5
                  ,
                  Run.trans_token (Run.matcher_token v6)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_use_module_member ((kind, body) : mt) : CST.use_module_member =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_module_identity (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_use_member (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_module_access ((kind, body) : mt) : CST.module_access =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `DOLLAR_id (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  trans_identifier (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Rese_id (
            trans_reserved_identifier (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Module_id_COLONCOLON_id (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_module_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_identifier (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Module_iden_COLONCOLON_id (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_module_identity (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_identifier (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_property ((kind, body) : mt) : CST.spec_property =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_literal_value (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_struct_signature ((kind, body) : mt) : CST.struct_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_struct_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_ability_decls (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_block_target_schema ((kind, body) : mt) : CST.spec_block_target_schema =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_struct_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_enum_signature ((kind, body) : mt) : CST.enum_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_enum_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_ability_decls (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_apply_pattern ((kind, body) : mt) : CST.spec_apply_pattern =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Public (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Inte (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_spec_apply_name_pattern (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_friend_declaration ((kind, body) : mt) : CST.friend_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_friend_access (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_use_fun ((kind, body) : mt) : CST.use_fun =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_module_access (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_module_access (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4),
            trans_function_identifier (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_apply_type ((kind, body) : mt) : CST.apply_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_module_access (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_type ((kind, body) : mt) : CST.function_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_function_type_parameters (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_function_type_parameters ((kind, body) : mt) : CST.function_type_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_type_ (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_type_ (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_ref_type ((kind, body) : mt) : CST.ref_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `AMP (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `AMPmut (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_type_ (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_tuple_type ((kind, body) : mt) : CST.tuple_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_type_ (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_type_ (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Apply_type (
            trans_apply_type (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Ref_type (
            trans_ref_type (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Tuple_type (
            trans_tuple_type (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Func_type (
            trans_function_type (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Prim_type (
            trans_primitive_type (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_type_arguments ((kind, body) : mt) : CST.type_arguments =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_annotation_item ((kind, body) : mt) : CST.annotation_item =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Id_EQ_lit_value (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_literal_value (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Id_LPAR_choice_lit_value_rep_COMMA_choice_lit_value_opt_COMMA_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  (match v2 with
                  | Alt (0, v) ->
                      `Lit_value (
                        trans_literal_value (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Module_access (
                        trans_module_access (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            (match v1 with
                            | Alt (0, v) ->
                                `Lit_value (
                                  trans_literal_value (Run.matcher_token v)
                                )
                            | Alt (1, v) ->
                                `Module_access (
                                  trans_module_access (Run.matcher_token v)
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                    )
                    v3
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v4
                  ,
                  Run.trans_token (Run.matcher_token v5)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Id_LPAR_id_EQ_choice_module_access_rep_COMMA_id_EQ_choice_module_access_opt_COMMA_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_identifier (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3),
                  (match v4 with
                  | Alt (0, v) ->
                      `Module_access (
                        trans_module_access (Run.matcher_token v)
                      )
                  | Alt (1, v) ->
                      `Lit_value (
                        trans_literal_value (Run.matcher_token v)
                      )
                  | _ -> assert false
                  )
                  ,
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1; v2; v3] ->
                          (
                            Run.trans_token (Run.matcher_token v0),
                            trans_identifier (Run.matcher_token v1),
                            Run.trans_token (Run.matcher_token v2),
                            (match v3 with
                            | Alt (0, v) ->
                                `Module_access (
                                  trans_module_access (Run.matcher_token v)
                                )
                            | Alt (1, v) ->
                                `Lit_value (
                                  trans_literal_value (Run.matcher_token v)
                                )
                            | _ -> assert false
                            )
                          )
                      | _ -> assert false
                      )
                    )
                    v5
                  ,
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v6
                  ,
                  Run.trans_token (Run.matcher_token v7)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_macro_module_access ((kind, body) : mt) : CST.macro_module_access =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_module_access (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_condition_properties ((kind, body) : mt) : CST.condition_properties =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_spec_property (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_spec_property (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_pragma ((kind, body) : mt) : CST.spec_pragma =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_spec_property (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_spec_property (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_native_struct_definition ((kind, body) : mt) : CST.native_struct_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_struct_signature (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_block_target ((kind, body) : mt) : CST.spec_block_target =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Module (
            Run.trans_token (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Spec_blk_target_schema (
            trans_spec_block_target_schema (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_use_declaration ((kind, body) : mt) : CST.use_declaration =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) ->
                `Use_fun (
                  trans_use_fun (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Use_module (
                  trans_use_module (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Use_module_member (
                  trans_use_module_member (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Use_module_members (
                  trans_use_module_members (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_name_expression ((kind, body) : mt) : CST.name_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_module_access (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_field_annotation ((kind, body) : mt) : CST.field_annotation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_field_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_type_ (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_variable ((kind, body) : mt) : CST.spec_variable =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Global (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Local (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v0
            ,
            trans_identifier (Run.matcher_token v1),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_type_ (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_function_parameter ((kind, body) : mt) : CST.function_parameter =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            (match v1 with
            | Alt (0, v) ->
                `Var_id (
                  trans_variable_identifier (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `DOLLAR_var_id (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_variable_identifier (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_type_ (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_positional_fields ((kind, body) : mt) : CST.positional_fields =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_type_ (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_type_ (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_ret_type ((kind, body) : mt) : CST.ret_type =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_type_ (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_bind ((kind, body) : mt) : CST.bind =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Opt_mut_var_id (
            (match v with
            | Seq [v0; v1] ->
                (
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v0
                  ,
                  trans_variable_identifier (Run.matcher_token v1)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Bind_unpack (
            trans_bind_unpack (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Var_id_AT_bind (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_variable_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_bind (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bind_field ((kind, body) : mt) : CST.bind_field =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            trans_field_identifier (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_bind (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bind_fields ((kind, body) : mt) : CST.bind_fields =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Bind_posi_fields (
            trans_bind_positional_fields (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bind_named_fields (
            trans_bind_named_fields (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bind_named_fields ((kind, body) : mt) : CST.bind_named_fields =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_bind_field (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_bind_field (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bind_positional_fields ((kind, body) : mt) : CST.bind_positional_fields =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_bind_field (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_bind_field (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_bind_unpack ((kind, body) : mt) : CST.bind_unpack =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_module_access (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_bind_fields (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_annotation ((kind, body) : mt) : CST.annotation =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_annotation_item (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_annotation_item (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_named_fields ((kind, body) : mt) : CST.named_fields =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_field_annotation (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_field_annotation (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_function_parameters ((kind, body) : mt) : CST.function_parameters =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_function_parameter (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_function_parameter (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_bind_list ((kind, body) : mt) : CST.bind_list =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Bind (
            trans_bind (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `LPAR_rep_bind_COMMA_opt_bind_RPAR (
            (match v with
            | Seq [v0; v1; v2; v3] ->
                (
                  Run.trans_token (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      (match v with
                      | Seq [v0; v1] ->
                          (
                            trans_bind (Run.matcher_token v0),
                            Run.trans_token (Run.matcher_token v1)
                          )
                      | _ -> assert false
                      )
                    )
                    v1
                  ,
                  Run.opt
                    (fun v -> trans_bind (Run.matcher_token v))
                    v2
                  ,
                  Run.trans_token (Run.matcher_token v3)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_lambda_bindings ((kind, body) : mt) : CST.lambda_bindings =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_bind (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_bind (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_datatype_fields ((kind, body) : mt) : CST.datatype_fields =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Posi_fields (
            trans_positional_fields (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Named_fields (
            trans_named_fields (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_function_signature ((kind, body) : mt) : CST.function_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.opt
              (fun v -> trans_modifier (Run.matcher_token v))
              v0
            ,
            Run.opt
              (fun v -> trans_modifier (Run.matcher_token v))
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_function_identifier (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v4
            ,
            trans_function_parameters (Run.matcher_token v5),
            Run.opt
              (fun v -> trans_ret_type (Run.matcher_token v))
              v6
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_spec_function_signature ((kind, body) : mt) : CST.spec_function_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_function_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v1
            ,
            trans_function_parameters (Run.matcher_token v2),
            trans_ret_type (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_macro_signature ((kind, body) : mt) : CST.macro_signature =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.opt
              (fun v -> trans_modifier (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_function_identifier (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_type_parameters (Run.matcher_token v))
              v3
            ,
            trans_function_parameters (Run.matcher_token v4),
            Run.opt
              (fun v -> trans_ret_type (Run.matcher_token v))
              v5
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_struct_definition ((kind, body) : mt) : CST.struct_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            trans_struct_signature (Run.matcher_token v1),
            trans_datatype_fields (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_postfix_ability_decls (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_variant ((kind, body) : mt) : CST.variant =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_variant_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_datatype_fields (Run.matcher_token v))
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_native_function_definition ((kind, body) : mt) : CST.native_function_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_function_signature (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_native_spec_function ((kind, body) : mt) : CST.native_spec_function =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_spec_function_signature (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_uninterpreted_spec_function ((kind, body) : mt) : CST.uninterpreted_spec_function =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_spec_function_signature (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_struct_item ((kind, body) : mt) : CST.struct_item =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Native_struct_defi (
            trans_native_struct_definition (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Struct_defi (
            trans_struct_definition (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_enum_variants ((kind, body) : mt) : CST.enum_variants =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_variant (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_variant (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_abort_expression ((kind, body) : mt) : CST.abort_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_annotate_expression ((kind, body) : mt) : CST.annotate_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_type_ (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_arg_list ((kind, body) : mt) : CST.arg_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expression (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_assign_expression ((kind, body) : mt) : CST.assign_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_unary_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary_expression ((kind, body) : mt) : CST.binary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Bin_oper_EQEQGT_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Bin_oper_BARBAR_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (2, v) ->
          `Bin_oper_AMPAMP_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (3, v) ->
          `Bin_oper_EQEQ_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (4, v) ->
          `Bin_oper_BANGEQ_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (5, v) ->
          `Bin_oper_LT_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (6, v) ->
          `Bin_oper_GT_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (7, v) ->
          `Bin_oper_LTEQ_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (8, v) ->
          `Bin_oper_GTEQ_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (9, v) ->
          `Bin_oper_DOTDOT_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (10, v) ->
          `Bin_oper_BAR_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (11, v) ->
          `Bin_oper_HAT_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (12, v) ->
          `Bin_oper_AMP_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (13, v) ->
          `Bin_oper_LTLT_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (14, v) ->
          `Bin_oper_GTGT_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (15, v) ->
          `Bin_oper_PLUS_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (16, v) ->
          `Bin_oper_DASH_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (17, v) ->
          `Bin_oper_STAR_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (18, v) ->
          `Bin_oper_SLASH_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (19, v) ->
          `Bin_oper_PERC_bin_oper (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_binary_operand (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_binary_operand (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_binary_operand ((kind, body) : mt) : CST.binary_operand =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Un_exp (
            trans_unary_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Bin_exp (
            trans_binary_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Cast_exp (
            trans_cast_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_block ((kind, body) : mt) : CST.block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_use_declaration (Run.matcher_token v))
              v1
            ,
            Run.repeat
              (fun v -> trans_block_item (Run.matcher_token v))
              v2
            ,
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_block_item ((kind, body) : mt) : CST.block_item =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Exp (
                  trans_expression (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Let_stmt (
                  trans_let_statement (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_borrow_expression ((kind, body) : mt) : CST.borrow_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `AMP (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `AMPmut (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_break_expression ((kind, body) : mt) : CST.break_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_label (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v -> trans_expression_term (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_call_expression ((kind, body) : mt) : CST.call_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_module_access (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
            ,
            trans_arg_list (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_cast_expression ((kind, body) : mt) : CST.cast_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_type_ (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_dereference_expression ((kind, body) : mt) : CST.dereference_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_dot_expression ((kind, body) : mt) : CST.dot_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_expression_term (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression_term (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_exp_field ((kind, body) : mt) : CST.exp_field =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_field_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Lambda_exp (
            trans_lambda_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `If_exp (
            trans_if_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `While_exp (
            trans_while_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Loop_exp (
            trans_loop_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Ret_exp (
            trans_return_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Abort_exp (
            trans_abort_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Assign_exp (
            trans_assign_expression (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Un_exp (
            trans_unary_expression (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Bin_exp (
            trans_binary_expression (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Cast_exp (
            trans_cast_expression (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Quan_exp (
            trans_quantifier_expression (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Iden_exp (
            trans_identified_expression (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `Match_exp (
            trans_match_expression (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Vec_exp (
            trans_vector_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression_list ((kind, body) : mt) : CST.expression_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_expression_term ((kind, body) : mt) : CST.expression_term =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Brk_exp (
            trans_break_expression (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Cont_exp (
            trans_continue_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Name_exp (
            trans_name_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Call_exp (
            trans_call_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Macro_call_exp (
            trans_macro_call_expression (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Pack_exp (
            trans_pack_expression (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Lit_value (
            trans_literal_value (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Unit_exp (
            trans_unit_expression (Run.matcher_token v)
          )
      | Alt (8, v) ->
          `Exp_list (
            trans_expression_list (Run.matcher_token v)
          )
      | Alt (9, v) ->
          `Anno_exp (
            trans_annotate_expression (Run.matcher_token v)
          )
      | Alt (10, v) ->
          `Blk (
            trans_block (Run.matcher_token v)
          )
      | Alt (11, v) ->
          `Spec_blk (
            trans_spec_block (Run.matcher_token v)
          )
      | Alt (12, v) ->
          `If_exp (
            trans_if_expression (Run.matcher_token v)
          )
      | Alt (13, v) ->
          `Dot_exp (
            trans_dot_expression (Run.matcher_token v)
          )
      | Alt (14, v) ->
          `Index_exp (
            trans_index_expression (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_field_initialize_list ((kind, body) : mt) : CST.field_initialize_list =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_exp_field (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_exp_field (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_identified_expression ((kind, body) : mt) : CST.identified_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_block_identifier (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_if_expression ((kind, body) : mt) : CST.if_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v5
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_index_expression ((kind, body) : mt) : CST.index_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_expression_term (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_lambda_expression ((kind, body) : mt) : CST.lambda_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_lambda_bindings (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            trans_expression (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_let_statement ((kind, body) : mt) : CST.let_statement =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_bind_list (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_type_ (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_loop_expression ((kind, body) : mt) : CST.loop_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_macro_call_expression ((kind, body) : mt) : CST.macro_call_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_macro_module_access (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
            ,
            trans_arg_list (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_match_arm ((kind, body) : mt) : CST.match_arm =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            trans_bind_list (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2),
            trans_expression (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_match_body ((kind, body) : mt) : CST.match_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_match_arm (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_match_arm (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_match_expression ((kind, body) : mt) : CST.match_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_match_body (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pack_expression ((kind, body) : mt) : CST.pack_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_module_access (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_arguments (Run.matcher_token v))
              v1
            ,
            trans_field_initialize_list (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_quantifier_binding ((kind, body) : mt) : CST.quantifier_binding =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Id_COLON_type (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_type_ (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Id_in_exp (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_identifier (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_quantifier_bindings ((kind, body) : mt) : CST.quantifier_bindings =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_quantifier_binding (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_quantifier_binding (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_quantifier_expression ((kind, body) : mt) : CST.quantifier_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Forall (
                  trans_forall (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Exists (
                  trans_exists (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            trans_quantifier_bindings (Run.matcher_token v1),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v2
            ,
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_return_expression ((kind, body) : mt) : CST.return_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_label (Run.matcher_token v))
              v1
            ,
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Exp_term (
                      trans_expression_term (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Exp (
                      trans_expression (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_abort_if ((kind, body) : mt) : CST.spec_abort_if =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_condition_properties (Run.matcher_token v))
              v1
            ,
            trans_expression (Run.matcher_token v2),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_abort_with_or_modifies ((kind, body) : mt) : CST.spec_abort_with_or_modifies =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Aborts_with (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Modifs (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_condition_properties (Run.matcher_token v))
              v1
            ,
            trans_expression (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v3
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v4
            ,
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_apply ((kind, body) : mt) : CST.spec_apply =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6; v7] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_spec_apply_pattern (Run.matcher_token v3),
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_spec_apply_pattern (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v4
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v5
            ,
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1; v2; v3] ->
                    (
                      Run.trans_token (Run.matcher_token v0),
                      trans_spec_apply_pattern (Run.matcher_token v1),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_spec_apply_pattern (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v2
                      ,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v3
                    )
                | _ -> assert false
                )
              )
              v6
            ,
            Run.trans_token (Run.matcher_token v7)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_block ((kind, body) : mt) : CST.spec_block =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Opt_spec_blk_target_spec_body (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.opt
                          (fun v -> trans_spec_block_target (Run.matcher_token v))
                          v0
                        ,
                        trans_spec_body (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Spec_func (
                  trans_spec_function (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_block_memeber ((kind, body) : mt) : CST.spec_block_memeber =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Spec_inva (
            trans_spec_invariant (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Spec_func (
            trans_spec_function (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Spec_cond (
            trans_spec_condition (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Spec_incl (
            trans_spec_include (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Spec_apply (
            trans_spec_apply (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Spec_pragma (
            trans_spec_pragma (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Spec_var (
            trans_spec_variable (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Spec_let (
            trans_spec_let (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_body ((kind, body) : mt) : CST.spec_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_use_declaration (Run.matcher_token v))
              v1
            ,
            Run.repeat
              (fun v -> trans_spec_block_memeber (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_condition ((kind, body) : mt) : CST.spec_condition =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Spec_cond_ (
            trans_spec_condition_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Spec_abort_if (
            trans_spec_abort_if (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Spec_abort_with_or_modifs (
            trans_spec_abort_with_or_modifies (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_condition_ ((kind, body) : mt) : CST.spec_condition_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Spec_cond_kind (
                  trans_spec_condition_kind (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Requis_opt_module (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.opt
                          (fun v -> Run.trans_token (Run.matcher_token v))
                          v1
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.opt
              (fun v -> trans_condition_properties (Run.matcher_token v))
              v1
            ,
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_function ((kind, body) : mt) : CST.spec_function =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Native_spec_func (
            trans_native_spec_function (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Usual_spec_func (
            trans_usual_spec_function (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Unin_spec_func (
            trans_uninterpreted_spec_function (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_include ((kind, body) : mt) : CST.spec_include =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_invariant ((kind, body) : mt) : CST.spec_invariant =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Update (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Pack (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Unpack (
                      Run.trans_token (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Module (
                      Run.trans_token (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_condition_properties (Run.matcher_token v))
              v2
            ,
            trans_expression (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_spec_let ((kind, body) : mt) : CST.spec_let =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v1
            ,
            trans_identifier (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_expression ((kind, body) : mt) : CST.unary_expression =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Un_exp_ (
            trans_unary_expression_ (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Borrow_exp (
            trans_borrow_expression (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Dere_exp (
            trans_dereference_expression (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Move_or_copy_exp (
            trans_move_or_copy_expression (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Exp_term (
            trans_expression_term (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_unary_expression_ ((kind, body) : mt) : CST.unary_expression_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_unary_op (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_usual_spec_function ((kind, body) : mt) : CST.usual_spec_function =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_spec_function_signature (Run.matcher_token v1),
            trans_block (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_vector_expression ((kind, body) : mt) : CST.vector_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `Vect (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Vect_type_rep_COMMA_type_opt_COMMA_GT_LBRACK (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4; v5] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_type_ (Run.matcher_token v1),
                        Run.repeat
                          (fun v ->
                            (match v with
                            | Seq [v0; v1] ->
                                (
                                  Run.trans_token (Run.matcher_token v0),
                                  trans_type_ (Run.matcher_token v1)
                                )
                            | _ -> assert false
                            )
                          )
                          v2
                        ,
                        Run.opt
                          (fun v -> Run.trans_token (Run.matcher_token v))
                          v3
                        ,
                        Run.trans_token (Run.matcher_token v4),
                        Run.trans_token (Run.matcher_token v5)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_expression (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> trans_expression (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_while_expression ((kind, body) : mt) : CST.while_expression =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression (Run.matcher_token v4)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_enum_definition ((kind, body) : mt) : CST.enum_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v0
            ,
            trans_enum_signature (Run.matcher_token v1),
            trans_enum_variants (Run.matcher_token v2),
            Run.opt
              (fun v -> trans_postfix_ability_decls (Run.matcher_token v))
              v3
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_constant ((kind, body) : mt) : CST.constant =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3; v4; v5; v6] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_type_ (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4),
            trans_expression (Run.matcher_token v5),
            Run.trans_token (Run.matcher_token v6)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_macro_function_definition ((kind, body) : mt) : CST.macro_function_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.opt
              (fun v -> trans_modifier (Run.matcher_token v))
              v0
            ,
            Run.trans_token (Run.matcher_token v1),
            trans_macro_signature (Run.matcher_token v2),
            trans_block (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_function_definition ((kind, body) : mt) : CST.function_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            trans_function_signature (Run.matcher_token v0),
            trans_block (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_enum_item ((kind, body) : mt) : CST.enum_item =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Enum_defi (
            trans_enum_definition (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_function_item ((kind, body) : mt) : CST.function_item =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Native_func_defi (
            trans_native_function_definition (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Macro_func_defi (
            trans_macro_function_definition (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Func_defi (
            trans_function_definition (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_module_body ((kind, body) : mt) : CST.module_body =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `SEMI (
                  Run.trans_token (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LCURL (
                  Run.trans_token (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Use_decl (
                      trans_use_declaration (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Friend_decl (
                      trans_friend_declaration (Run.matcher_token v)
                    )
                | Alt (2, v) ->
                    `Cst (
                      trans_constant (Run.matcher_token v)
                    )
                | Alt (3, v) ->
                    `Func_item (
                      trans_function_item (Run.matcher_token v)
                    )
                | Alt (4, v) ->
                    `Struct_item (
                      trans_struct_item (Run.matcher_token v)
                    )
                | Alt (5, v) ->
                    `Enum_item (
                      trans_enum_item (Run.matcher_token v)
                    )
                | Alt (6, v) ->
                    `Spec_blk (
                      trans_spec_block (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_module_definition ((kind, body) : mt) : CST.module_definition =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_module_identity (Run.matcher_token v1),
            trans_module_body (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source_file ((kind, body) : mt) : CST.source_file =
  match body with
  | Children v ->
      Run.repeat
        (fun v -> trans_module_definition (Run.matcher_token v))
        v
  | Leaf _ -> assert false

(*
   Costly operation that translates a whole tree or subtree.

   The first pass translates it into a generic tree structure suitable
   to guess which node corresponds to each grammar rule.
   The second pass is a translation into a typed tree where each grammar
   node has its own type.

   This function is called:
   - once on the root of the program after removing extras
     (comments and other nodes that occur anywhere independently from
     the grammar);
   - once of each extra node, resulting in its own independent tree of type
     'extra'.
*)
let translate_tree src node trans_x =
  let matched_tree = Run.match_tree children_regexps src node in
  Option.map trans_x matched_tree


let translate_extra src (node : Tree_sitter_output_t.node) : CST.extra option =
  match node.type_ with
  | "whitespace" ->
      (match translate_tree src node trans_whitespace with
      | None -> None
      | Some x -> Some (Whitespace (Run.get_loc node, x)))
  | "line_comment" ->
      (match translate_tree src node trans_line_comment with
      | None -> None
      | Some x -> Some (Line_comment (Run.get_loc node, x)))
  | "block_comment" ->
      (match translate_tree src node trans_block_comment with
      | None -> None
      | Some x -> Some (Block_comment (Run.get_loc node, x)))
  | "empty_line" ->
      (match translate_tree src node trans_empty_line with
      | None -> None
      | Some x -> Some (Empty_line (Run.get_loc node, x)))
  | "annotation" ->
      (match translate_tree src node trans_annotation with
      | None -> None
      | Some x -> Some (Annotation (Run.get_loc node, x)))
  | _ -> None

let translate_root src root_node =
  translate_tree src root_node trans_source_file

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let opt_program, extras =
     Run.translate
       ~extras
       ~translate_root:(translate_root src)
       ~translate_extra:(translate_extra src)
       orig_root_node
  in
  Parsing_result.create src opt_program extras errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

